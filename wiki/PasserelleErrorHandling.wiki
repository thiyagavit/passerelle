#summary Passerelle offers a number of error handling features, targeting both developers and modelers.

= Introduction =

Passerelle models can be executed in different settings, both with possibilities for user interactions via a UI 
and in fully-automated runtimes without the possibility/need for user interactions.
In some use-cases, such as scientific workflows, the actual number of runs per time is limited, but the processing done per run may be complex and long.
In other cases, many tens of thousands of runs are done per day.

In all these cases, there is a need for deterministic error processing.

Below, the different error handling features of Passerelle are presented, in the context of model executions.
We look at what happens when one or more actors encounter an error, as the actors are the central elements to implement all logic in Passerelle models.
"Hardcore" technical errors within the engine itself are outside of the scope of this documentation.

= Error handling within the model =

== At model startup ==
When a model is launched, several steps need to be taken before it is fully operational :
  * Parse the model definition, from the xml/moml file
  * Construct all contained entities, their relations, configuration parameters etc
  * Invoke the `preInitialize` and `initialize` methods on all actors. 
    This is also where Passerelle adds validation steps.
  
When errors are encountered in these initial steps, the model execution will be impossible or will automatically stop.
If the execution happens within a UI-application, the user will typically be notified about such errors via pop-ups or log viewers.

== During model execution ==
When the actor initializations are done, the model is fully in "processing" mode.
The exact logic to go from initialization to processing depends on the type of Director that is used, but can be ignored for our purposes here.

When an actor encounters an error in its processing, the resulting behaviour depends on the error's Severity:
  * Fatal errors by default cause the model execution to stop abruptly.
  * For non-fatal errors, modelers can include specific error-handling logic inside the models :
    * If the actor-in-error's error output port is connected, Passerelle sends an error message containing the error info and the actor's last received message.
    * If the actor's error output is not connected, the actor hands over the error info to the model Director.

These options for non-fatal errors are somewhat similar to the distinction between local try/catch structures 
with explicit error handling close to the source of the error (the case with connected error port), 
versus "uncaught" errors being propagated to the top-level in the call-stack, or model hierarchy in this case.

=== Continuation via the actor's error output port ===
This requires that the error port is actually connected to something.
If the modeler chooses this option, the actor's error output port can be connected 
to a `com.isencia.passerelle.actor.error.ErrorCatcher` actor, that is able to "unwrap" the error message and then forward the contained "original" message.
The `ErrorCatcher` actor can then be connected to a specific error-continuation logic within the model.
In special cases, when the error can just be ignored, the `com.isencia.passerelle.actor.general.DevNullActor` can come in handy.

A simple use-case could be to catch an error, and then send an email with the failed message, as illustrated below.

http://svn.codespot.com/a/eclipselabs.org/passerelle/wiki/img/Model_ErrorCatcher.jpg

=== Error propagation via the Director ===
When the error-handling is delegated to the Director, this one will check the model for the presence of `com.isencia.passerelle.ext.ErrorCollector` instances.
If there are some, the error is delivered to them and its processing can continue from there.
`com.isencia.passerelle.actor.error.ErrorObserver` actors are typically used in this way.
Their usage allows to have one-or-more central error handling solutions within a model, that can be triggered
whenever an error occurs in any of the model actors, without needing to connect all actors' error output ports to it.

In this model, the `ErrorObserver` is used to gather any error that can occur during the model execution, and simply puts the request
that is being processed in an error status.
I.c.o. an error in the final part of the sequence, to prevent endless loops with the `ErrorObserver`, a `DevNull` is connected to the error ports.

http://svn.codespot.com/a/eclipselabs.org/passerelle/wiki/img/Model_ErrorObserver_DevNull.jpg

Besides the `ErrorObserver` actor, that can be added by the modelers, `ErrorCollector` implementations can also be registered by the runtime/engine, 
e.g. to log "uncaught" errors in dedicated views or store them in a DB etc.

  For the "techies" : a submodel corresponds to an instance of `ptolemy.kernel.CompositeEntity`. 
  Model elements can be of different kinds, but for our purposes we consider either Actors or `ptolemy.kernel.util.Attribute`s.
  The runtime can dynamically add "Mixin"-implementations of `ErrorCollector` and `Attribute` to a `CompositeEntity` and thus to a (sub)model. 
  
*For the near future*
Currently, all `ErrorCollector`s in a model are treated "as equals". 
With the next Passerelle core version (v8.2), this will change to having an error collection "scope" per model/submodel level.
When the error port is not connected, the errors of an actor in a submodel will first be delivered to the `ErrorCollector`(s) present in the submodel.
Also, work is ongoing to add filtering/selection options for `ErrorObserver`s, so more fine-grained error handling can be modeled, depending on the type of error.
When an error can not be delivered to a matching submodel's `ErrorObServer` it will be propagated upwards in the model hierarchy.

= Actor error handling =
== Actor template methods and error control strategy ==
The possibilities described above are the default behaviour of Passerelle, and are provided by the default implementation of 
a `com.isencia.passerelle.ext.ErrorControlStrategy`, namely `com.isencia.passerelle.ext.impl.DefaultActorErrorControlStrategy`.

Through the common actor base class `com.isencia.passerelle.actor.Actor`, all actor life-cycle methods have been made final 
to implement the template method pattern. The resulting `do...()` methods, to be implemented/overridden by actor implementations, 
all have a dedicated checked exception that can be thrown, all subclasses of `com.isencia.passerelle.core.PasserelleException`.

{{{
// ...
public abstract class Actor extends TypedAtomicActor implements IMessageCreator {
//...
  /**
   * Template method implementation for preinitialize().
   * 
   * @throws InitializationException
   * @see ptolemy.actor.AtomicActor#preinitialize()
   */
  protected void doPreInitialize() throws InitializationException {
  }
//...
  /**
   * Template method implementation for prefire(). Method that can be overriden to implement precondition checking for the fire() loop. By default, returns
   * true. If the method returns true, the actor's fire() method will be called. If the method returns false, preFire() will be called again repetitively till
   * it returns true. So it's important that for "false" results there is some blocking/waiting mechanism implemented to avoid wild looping!
   * 
   * @return flag indicating whether the actor is ready for fire()
   * @see ptolemy.actor.AtomicActor#prefire()
   */
  protected boolean doPreFire() throws ProcessingException {
    return true;
  }
//...
  /**
   * Template method implementation for wrapup().
   * 
   * @throws TerminationException
   * @see ptolemy.actor.AtomicActor#wrapup()
   */
  protected void doWrapUp() throws TerminationException {
  }
//...
}
}}}

Inside the wrapping methods, these exceptions are caught and passed to the actor's error control strategy.

For example :

{{{
//...
  final public void wrapup() throws IllegalActionException {
    getLogger().trace("{} - wrapup() - entry", getInfo());

    try {
      doWrapUp();
    } catch (TerminationException e) {
      getErrorControlStrategy().handleTerminationException(this, e);
    }
//...
  }
//...
}}}

For the main actor iteration methods (preFire, fire, postFire), also `java.lang.RuntimeException`s are delegated to the error control strategy.
These are by default handled as fatal, i.e. will cause the model execution to be aborted.

== Actor development conventions ==

- wrap all exceptions in the defined checked exception types
- put the last received message as exception context
- put error codes in the exception's message (pending the arrival of a formal errorcode field for `PasserelleException`s)


