package com.isencia.passerelle.process.actor.forkjoin;

import com.isencia.passerelle.actor.ProcessingException;
import com.isencia.passerelle.message.ManagedMessage;

/**
 * Defines the contract for actors that generate message sequences.
 * <p>
 * Such actors often need to maintain some state information on the progress and/or completion
 * of the processing of "their" generated sequences.<br/>
 * To avoid memory problems in model executions with high throughput rates, a state retention policy should be implemented.
 * This must include following elements :
 * <ul>
 * <li>enable/disable statefulness</li>
 * <li>set a retention limit (time-based or count-based)</li>
 * <li>set an <code>EvictedMessagesHandler</code> that determines what must be done when messages/sequences are evicted due to retention limitation issues</li>
 * </ul>
 * </p>
 * <p>
 * A stateful <code>MessageSequenceSource</code> can be configured with a <code>JoinStrategy</code> to define any desired
 * joining logic that should be performed on a message sequence once each member message has been individually processed.
 * </p>
 * <p>
 * Stateless instances are by definition unable to join previously processed sequenced messages, 
 * so don't have a use for a <code>JoinStrategy</code>.
 * </p>
 * 
 * @author erwin
 */
public interface MessageSequenceSource {
  
  // Header name to set the name of the MessageSequenceSource actor in each outgoing msg.
  // Join actors must then search for this actor with that name.
  // This assumes that both actors are within the same containing CompositeActor.
  String HEADER_SEQ_SRC = "__PSRL_SEQ_SRC_REF";
  
  /**
   * 
   * @return true if this source retains state on progress of its generated sequenced messages.
   */
  boolean isStateful();

  /**
   * 
   * @param seqMsg
   * @return true if the seqMsg was generated by this source
   */
  boolean fromThisSource(ManagedMessage seqMsg);
  
  /**
   * A stateful <code>MessageSequenceSource</code> with a configured <code>JoinStrategy</code> will return the joined result message,
   * when all member messages of the sequence have been marked as processed.<br/> 
   * If no <code>JoinStrategy</code> has been set, this method will return this last received <code>seqMsg</code>. <br/>
   * If the sequence has not yet been completely processed, or this seqMsg is not <code>fromThisSource</code>, this method returns null.
   * <br/>
   * A stateless <code>MessageSequenceSource</code> always returns the received <code>seqMsg</code>.
   * 
   * @param seqMsg
   * @return the joined result of all retained messages for seqMsg's sequence, if all have finished their individual processing; 
   * null otherwise, i.e. when there are still messages from the sequence that have not yet returned from their processing.
   * @throws ProcessingException
   */
  ManagedMessage joinProcessedMessageInSequence(ManagedMessage seqMsg) throws ProcessingException;

  /**
   * 
   * @return the currently configured strategy for joining message sequences,
   * after their messages have been individually processed.
   */
  JoinStrategy getJoinStrategy();
  
  /**
   * Sets the strategy for joining message sequences,
   * after their messages have been individually processed.
   * @param joinStrategy
   */
  void setJoinStrategy(JoinStrategy joinStrategy);
  
  /**
   * @return the handler that will be notified of messages that are being evicted from the source's state management cache
   */
  EvictedMessagesHandler getEvictedMessagesHandler();

  /**
   * @param evictedMessagesHandler the handler that must be notified of messages that are being evicted from the source's state management cache
   */
  void setEvictedMessagesHandler(EvictedMessagesHandler evictedMessagesHandler);
}
