/* Copyright 2011 - iSencia Belgium NV

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */

package com.isencia.passerelle.domain.et.impl;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.isencia.passerelle.domain.et.Event;
import com.isencia.passerelle.domain.et.EventDispatchReporter;
import com.isencia.passerelle.domain.et.EventDispatcher;
import com.isencia.passerelle.domain.et.EventError;
import com.isencia.passerelle.domain.et.EventHandler;
import com.isencia.passerelle.domain.et.EventRefusedException;

/**
 * A dispatcher that allows multi-threaded event dispatching, with a configurable number of threads.
 * <p>
 * This dispatcher executes a model per "synchronous execution region" (SER), using Executors and Callables from java.util.concurrent. A SER is defined as a
 * connected part of a model where all actors have synchronous fire/process implementations. This implies that when the actor iteration returns, any "next"
 * events generated by the actors will already be present on the event Q, and SER execution can directly continue.
 * </p>
 * <p>
 * The effective kick-off of the dispatching is triggered by the source actor(s) present in the model. Each source actor's invocation of
 * Director.fireAtCurrentTime(...) will trigger a new SER-execution thread. In typical models there is only one source actor, so only one execution thread will
 * be triggered at model start-up. To activate parallel execution, the model should contain Fork/Join actors. The Fork actor will trigger an extra execution
 * thread per forked output. The Join actor will effectively stop the execution threads of all incoming channels, except for the final one that completes all
 * branches. And the execution thread of that final one will continue to execute the remainder of the SER after the Join actor.
 * </p>
 * <p>
 * The net result is that models with parallel synchronous regions should see parallel execution, but only when explicitly using Fork/Join actors. And all of
 * this should happen more-or-less autonomously, i.e. without explicit graph analysis logic or pre-calculated execution scheduling.
 * </p>
 * <p>
 * The complete event-dispatching/processing-chain for a SER is handled inside a Callable, executed in its single thread as allocated by the controlling
 * Executor. This Callable maintains its own private eventQ and dispatcher. When the SER's eventQ is empty, this implies that there is no further synchronous
 * execution progress possible anymore. Then either the model execution is finished as a whole, or other SERs are still executing and/or the model is waiting
 * for external/asynchronous/... events.
 * </p>
 * <p>
 * When a SER-execution is done, the event history info is aggregated in the overall history maintained by the parent SynchExecutionRegionDispatcher, and the SER's
 * dispatcher is reinitialized and could be potentially reused for a next SER's execution.
 * </p>
 * <p>
 * REMARK : It is assumed that "synchronous" actors iterate "quickly", i.e. return quickly from their fire/process (and prefire/postfire). Slowly-iterating
 * actors should be implemented asynchronously to optimally take advantage of the multi-threading.
 * </p>
 * 
 * @author delerw
 */
public class SynchExecutionRegionDispatcher implements EventDispatcher, EventDispatchReporter {

  private final static Logger LOGGER = LoggerFactory.getLogger(SynchExecutionRegionDispatcher.class);

  private String name;

  private List<Event> eventHistory = new LinkedList<Event>();
  private List<Event> unhandledEvents = new LinkedList<Event>();
  private List<EventError> eventErrors = new LinkedList<EventError>();

  private EventHandler eventHandlers[];

  // state variables for managing the shutdown sequence
  private volatile boolean active = false;
  private volatile boolean forcedShutdown = false;

  private ThreadLocal<SynchExecRegionDispatcher> serDispatchers;
  private Set<SynchExecRegionDispatcher> __serDispatchers = new HashSet<SynchExecutionRegionDispatcher.SynchExecRegionDispatcher>();

  private ExecutorService dispatcherExecutor;

  public SynchExecutionRegionDispatcher(String name, EventHandler... handlers) {
    this.name = name;
    eventHandlers = handlers;

    dispatcherExecutor = Executors.newFixedThreadPool(10);
  }

  public String getName() {
    return name;
  }

  public void initialize() {
    serDispatchers = new ThreadLocal<SynchExecutionRegionDispatcher.SynchExecRegionDispatcher>();
    clearEvents();
    active = true;
    forcedShutdown = false;
    for (EventHandler evtHandler : eventHandlers) {
      evtHandler.initialize();
    }
  }

  public void accept(Event e) throws EventRefusedException {
    if (!active) {
      throw new EventRefusedException(e, "Dispatcher inactive", this, new IllegalStateException());
    }
    try {
      SynchExecRegionDispatcher serDispatcher = serDispatchers.get();
      if (serDispatcher == null) {
        serDispatcher = new SynchExecRegionDispatcher(getName() + " - " + Thread.currentThread().getName(), eventHandlers);
        serDispatcher.initialize();
        synchronized(this) {
          __serDispatchers.add(serDispatcher);
        }
      }
      serDispatcher.accept(e);
    } catch (Exception e1) {
      throw new EventRefusedException(e, "Error accepting event", this, e1);
    }
  }

  public boolean dispatch(long timeOut) {
    if (forcedShutdown) {
      throw new IllegalStateException("Dispatcher forced to shutdown");
    }
    SynchExecRegionDispatcher serDispatcher = serDispatchers.get();
    if (serDispatcher == null) {
      return false;
    } else {
      serDispatcher.setTimeOut(timeOut);
      Future<Boolean> dispatchResult = dispatcherExecutor.submit(serDispatcher);
      try {
        return dispatchResult.get();
      } catch (ExecutionException e) {
        LOGGER.error("Error in SER event dispatching", e.getCause());
        return false;
      } catch (InterruptedException e) {
        LOGGER.warn("SER event dispatching was interrupted", e);
        // TODO check advice for thread interruption forwarding : need to set thread to interrupted again?
        return false;
      } finally {
        synchronized (this) {
          eventErrors.addAll(serDispatcher.getEventErrors());
          eventHistory.addAll(serDispatcher.getEventHistory());
          unhandledEvents.addAll(serDispatcher.getUnhandledEvents());
          
          serDispatchers.remove();
          __serDispatchers.remove(serDispatcher);
        }
      }
    }
  }

  public List<Event> getEventHistory() {
    return eventHistory;
  }

  public List<Event> getUnhandledEvents() {
    return unhandledEvents;
  }

  public List<EventError> getEventErrors() {
    return eventErrors;
  }

  public void clearEvents() {
    eventHistory.clear();
    unhandledEvents.clear();
    eventErrors.clear();
  }

  public void shutdown() {
    active = false;
  }

  public List<Event> shutdownNow() {
    shutdown();
    forcedShutdown = true;
    List<Event> pendingEvents = new ArrayList<Event>();
    for(SynchExecRegionDispatcher serDispatcher : __serDispatchers) {
      pendingEvents.addAll(serDispatcher.shutdownNow());
    }
    return pendingEvents;
  }

  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
    if (active)
      return false;
    // TODO do something here to block till all events have been processed
    return false;
  }

  @Override
  public String toString() {
    return "ThreadPoolEventDispatcher [name=" + name + ", active=" + active + "]";
  }

  /**
   * @author erwin
   */
  private class SynchExecRegionDispatcher extends SimpleEventDispatcher implements Callable<Boolean> {

    private long timeOut = 1000;

    public SynchExecRegionDispatcher(String name, EventHandler[] handlers) {
      super(name, handlers);
    }

    public long getTimeOut() {
      return timeOut;
    }

    public void setTimeOut(long timeOut) {
      this.timeOut = timeOut;
    }

    public Boolean call() throws Exception {
      LOGGER.info("Starting SynchExecRegionDispatcher {}", getName());
      serDispatchers.set(this);
      boolean hasDispatchedSomething = false;
      try {
        boolean continueDispatch = true;
        while (continueDispatch) {
          continueDispatch = dispatch(timeOut);
          if (continueDispatch == true) {
            hasDispatchedSomething = true;
          }
        }
      } finally {
        LOGGER.info("Terminating SynchExecRegionDispatcher {}", getName());
      }
      serDispatchers.remove();
      return hasDispatchedSomething;
    }
  }
}
